# 享元模式（Flyweight Pattern）
> 运用共享技术有效地支持大量细粒度的对象
* 减少创建对象的数量，以减少内存占用和提高性能
* 重用现有的同类对象，如果未找到匹配的对象，则创建新对象
## 使用场景
* 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。
* 享元模式，换句话说就是共享对象，在某些对象需要重复创建，且最终只需要得到单一结果的情况下使用。因为此种模式是利用先前创建的已有对象，通过某种规则去判断当前所需对象是否可以利用原有对象做相应修改后得到想要的效果
## 结构图
![](https://cdn.u1.huluxia.com/g3/M01/48/88/wKgBOV5LsASAWS0oAAsCFCp7wmI297.png)
* Flyweight 所有具体享元类或接口，通过这个接口Flyweight，可以接受并作用于外部状态
* FlyweightFactory 享元工厂，用来创建并管理Flyweight对象
* ConcreteFlyweight 具体的类

## 注意事项

* 在享元模式这样理解，“享”就表示共享，“元”表示对象
* 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式
* 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用HashMap/HashTable 存储
* 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率
* 享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方.
* 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。
* 享元模式经典的应用场景是需要缓冲池的场景，比如String 常量池、数据库连接池


## 在jdk中的应用
* String常量池
* integer 缓存
* 连接池


